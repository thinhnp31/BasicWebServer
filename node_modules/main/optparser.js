"use strict";

var fs = require('fs')
, extend = require('util')._extend
, parseArgs = require('minimist');

/*
Given a title, depth, and markdown, return the sections that the query matches.
*/
var getSections = exports.getSections = function(title, level, markdown) {

	// What parts do we consider the start of a hash section?
	var hashes = new Array(level+1).join('#')
	, hashExp = new RegExp('^' + hashes + '[^#]*$')
	, hashTitleExp = new RegExp('^' + hashes + '[^#]*' + title +'\\s*$')
	, dashExp;

	if (level === 1) { dashExp = /^==+$/; }
	else if (level === 2) { dashExp = /^--+$/; }

	var parsed = markdown.split('\n').reduce(function(result, line) {

		var hasHash = hashExp.test(line)
		, hasHashTitle = hashTitleExp.test(line)
		, hasHashTitlePrev = hashTitleExp.test(result.previous)
		, hasDash = dashExp && dashExp.test(line)
		, hasDashTitle = dashExp && dashExp.test(line) &&
			result.previous.indexOf(title) !== -1;

		// If we haven't added anything to the current section, look for a line
		// that marks the beginning
		if (result.currentSection.length === 0) {
			if (hasHashTitle) {
				result.currentSection.push(line);
			} else if (hasHashTitlePrev || hasDashTitle) {
				result.currentSection.push(result.previous);
				result.currentSection.push(line);
			}
		}
		// Process current section - we have a beginning
		else {
			// Check if we are at the end of this section (hash)
			if (hasHash) {
				result.sections.push(result.currentSection.join('\n'));
				result.currentSection = [];
			}
			// End of section? (dash)
			else if (hasDash) {
				line = result.currentSection.pop() + '\n' + line;
				result.sections.push(result.currentSection.join('\n'));
				result.currentSection = [];
			}
			// Not ending, continue adding lines to current section
			else {
				result.currentSection.push(line);
			}
		}

		result.previous = line;
		return result;
	}, {
		currentSection: [], // The current section lines
		previous: undefined, // The previous row's value
		sections: [] // The final result
	});

	// kick any lingering current sections into the results
	if (parsed.currentSection.length > 0) {
		parsed.sections.push(parsed.currentSection.join('\n'));
	}

	return parsed.sections;
};


/*
Given a single flag section from markdown, return back information about it.
*/
var parseFlagSection = exports.parseFlagSection = function(section) {

	var groups = /(?:#{3,}\s*)(.+?)(?:\((.*)\)|$)/gm.exec(section)
	, flags = groups[1]
	, parens = groups[2];

	var parsedFlags = flags.split(',').map(function(flag) {
		return flag
			.replace(/--?/, '') // remove dashes
			.replace(/=/, ' ') // replace any '=' with ' '
			.trim().replace(/  +/, ' '); // remove excess space
	}).map(function(flag) {
		var parts = flag.split(' ');
		return { name: parts[0], placeholder: parts[1] };
	});

	var result = {}
	, name = parsedFlags[0].name;

	result[name] = {};

	var aliasName = parsedFlags[1] && parsedFlags[1].name;
	if (aliasName) {
		result[name].alias = aliasName;
	}

	var placeholders = parsedFlags
		.map(function(flag) { return flag.placeholder; })
		.filter(function(placeholder) {
			return typeof placeholder !== 'undefined';
		})
	, hasPlaceholders = placeholders.length > 0;

	// no placeholders? it's a boolean flag
	if (!hasPlaceholders) {
		result[name].type = 'boolean';
	}
	// check to see if quotes are used to force it to be a string
	else if (/'|"/.test(placeholders.join(''))) {
		result[name].type = 'string';
	}

	if (/required/.test(parens)) {
		result[name].required = true;
	}

	var defaultGroup = /default=([\w\$]+)/gm.exec(parens);
	if (defaultGroup && defaultGroup[1]) {
		var isEnvVar = defaultGroup[1].substring(0, 1) === '$';
		if (isEnvVar) {
			var envVar = defaultGroup[1].replace('$', '');
			if (typeof process.env[envVar] !== 'undefined') {
				result[name].default = process.env[envVar];
			}
		} else {
			result[name].default = defaultGroup[1];
		}
	}

	return result;
};

/*
Builds the attributes object that minimist expects to receive based on our
option configuration that we pass in. It basically bunches it all together.
*/
var getAttributes = exports.getAttributes = function(optionConfig) {

	var attributes = {
		string: [],
		boolean: [],
		alias: {},
		default: {}
	};

	var optionName, option;

	for (optionName in optionConfig) {

		option = optionConfig[optionName];

		// load in types for this flag
		if (option.type) {
			try { attributes[option.type].push(optionName); }
			catch (error) {
				throw new Error('invalid type ' + option.type);
			}
		}

		// load in any alias for this option
		if (option.alias) {
			attributes.alias[option.alias] = optionName;
		}

		// load in any default values for this option
		if (option.default) {
			attributes.default[optionName] = option.default;
		}
	}

	return attributes;
};

var handleOptions = exports.handleOptions = function(argv, optionConfig) {

	var attributes = getAttributes(optionConfig)
	, parsed = parseArgs(argv || [], attributes);

	// check for any required options that are missing
	for (var optionName in optionConfig) {
		var isRequired = optionConfig[optionName].required;

		if (isRequired && !parsed[optionName]) {
			throw new Error('Missing required option ' + optionName);
		}
	}

	return parsed;
};

var parseOptions = exports.parseOptions = function(markdown) {
	if (!markdown) { return {}; }

	var optionMarkdown = getSections('OPTIONS', 2, markdown)[0];

	if (!optionMarkdown) { return {}; }

	var flagMarkdownSections = getSections('-.*', 3, optionMarkdown);

	return flagMarkdownSections.reduce(function(value, current) {
		return extend(value, parseFlagSection(current));
	}, {});
};

var parse = exports.parse = function(argv, markdown) {
	var self = {};

	self.options = handleOptions(argv, parseOptions(markdown));

	// Retrieves the value of a positional argument or a flag based on if a
	// number or a string is provided.
	self.getValue = function(positionOrFlag) {
		if (typeof positionOrFlag === 'string') {
			return self.options[positionOrFlag];
		}
		if (typeof positionOrFlag === 'number') {
			return self.options._[positionOrFlag];
		}
		throw new Error('provide a position (number) or a flag (string)');
	};

	return self;
};
